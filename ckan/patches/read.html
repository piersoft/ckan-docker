{% extends "package/read_base.html" %}

{% block primary_content_inner %}
  {{ super() }}
  {% block package_description %}
    {% if pkg.private %}
      <span class="dataset-private badge badge-inverse pull-right">
        <i class="fa fa-lock"></i>
        {{ _('Private') }}
      </span>
    {% endif %}
    <h1>
      {% block page_heading %}
        {{ h.dataset_display_name(pkg) }}
        {% if pkg.state.startswith('draft') %}
          [{{ _('Draft') }}]
        {% endif %}
        {% if pkg.state == 'deleted' %}
          [{{ _('Deleted') }}]
        {% endif %}
      {% endblock %}
    </h1>
    {% block package_notes %}
      {% if pkg.notes %}
        <div class="notes embedded-content">
          {{ h.render_markdown(h.get_translated(pkg, 'notes')) }}
        </div>
      {% endif %}
    {% endblock %}
  {% endblock %}

  {% block package_resources %}
    {% snippet "package/snippets/resources_list.html", pkg=pkg, resources=pkg.resources,
      can_edit=h.check_access('package_update', {'id':pkg.id }) %}
{# Container per mostrare la quality measure dall'API GAL --- #}
<div id="quality_meas_container" style="margin:1em 0; padding:0.5em; border:1px solid #ccc; background:#f9f9f9;">
  <strong>
    <a href="https://data.europa.eu/mqa/methodology?locale=it" target="_blank" style="text-decoration:none; color:#0066cc;">
      Punteggio qualità dal portale europeo <span title="Scopri la metodologia">ℹ️</span>
    </a>:
  </strong>
  <span class="qm-value">Caricamento…</span>
</div>
  {% endblock %}

  {% block package_tags %}
    {% snippet "package/snippets/tags.html", tags=pkg.tags %}
  {% endblock %}

  {% block package_additional_info %}
    {% snippet "package/snippets/additional_info.html", pkg_dict=pkg %}
  {% endblock %}

{% block scripts %}
  {{ super() }}
<script>
(function(){
  "use strict";

  function getDatasetNameFromURL() {
    const parts = window.location.pathname.split("/");
    return parts[2] || null;  // /dataset/<name>
  }

  async function getIdentifierFromTTL() {
    try {
      const datasetName = getDatasetNameFromURL();
      if (!datasetName) return null;

      const ttlUrl = "/dataset/" + datasetName + ".ttl";
      console.log("Carico TTL:", ttlUrl);

      const ttl = await fetch(ttlUrl).then(r => r.text());
      const lines = ttl.split("\n");

      let inDatasetBlock = false;
      let bracketDepth = 0;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();

        if (!trimmed || trimmed.startsWith("#")) continue;

        if (!inDatasetBlock) {
          // Trova l'inizio del subject Dataset
          // es: <...> a dcatapit:Dataset, dcat:Dataset ;
          const start = line.match(/^\s*<[^>]+>\s+a\s+.*\b(dcat:Dataset|dcatapit:Dataset)\b.*[;.]?\s*$/);
          if (start) {
            inDatasetBlock = true;
            bracketDepth = 0;

            // aggiorna bracketDepth anche sulla riga di start (di solito 0)
            bracketDepth += (line.match(/\[/g) || []).length;
            bracketDepth -= (line.match(/\]/g) || []).length;

            // se chiude subito con "." (raro), finisce
            if (/\.\s*$/.test(line)) break;
          }
          continue;
        }

        // Siamo nel blocco Dataset: aggiorna profondità [] PRIMA di valutare match
        bracketDepth += (line.match(/\[/g) || []).length;
        bracketDepth -= (line.match(/\]/g) || []).length;

        // Se siamo DENTRO un blank node, ignora eventuali dct:identifier (tipo creator/publisher)
        if (bracketDepth === 0) {
          const m = line.match(/^\s*dct:identifier\s+"([^"]+)"\s*[;.]?\s*$/);
          if (m) {
            const raw = m[1].trim();
            if (raw && raw !== "None") {
              const identifier = raw
                .replace(/[:.]/g, "-")
                .replace(/-+/g, "-")
                .replace(/^-+|-+$/g, "");

              console.log("Identifier dataset estratto (fuori da blank node) e normalizzato:", identifier);
              return identifier;
            }
          }
        }

        // Fine subject Dataset
        if (/\.\s*$/.test(line)) {
          break;
        }
      }

      console.warn("Identifier dataset non trovato nel blocco Dataset (fuori da blank node)");
      return null;

    } catch (err) {
      console.error("Errore lettura TTL:", err);
      return null;
    }
  }

  // 3️⃣ Chiamata API qualità EU (uguale a prima)
  function updateQuality(identifier) {
    const elem = document.querySelector("#quality_meas_container .qm-value");
    if (!elem || !identifier) return;

    const apiUrl =
      "https://data.europa.eu/api/hub/search/search" +
      "?filters=dataset" +
      "&field=quality_meas" +
      "&q=" + encodeURIComponent('"' + identifier + '"');

    fetch(apiUrl)
      .then(resp => resp.json())
      .then(data => {
        const qm = data?.result?.results?.[0]?.quality_meas?.scoring;

        if (qm !== undefined) {
          let label = "";
          let color = "black";

          if (qm >= 351) { color = "green"; label = "Eccellente"; }
          else if (qm >= 221) { color = "goldenrod"; label = "Buono"; }
          else if (qm >= 121) { color = "red"; label = "Sufficiente"; }
          else { color = "red"; label = "Scarso"; }

          elem.innerHTML = `<span style="color:${color}; font-weight:bold;">${qm} (${label})</span>`;
        } else {
          elem.textContent = "non ancora censito";
        }
      })
      .catch(err => {
        console.error("Errore API qualità:", err);
        elem.textContent = "Errore API";
      });
  }

  async function init() {
    const identifier = await getIdentifierFromTTL();

    if (identifier) {
      updateQuality(identifier);
    } else {
      const elem = document.querySelector("#quality_meas_container .qm-value");
      if (elem) elem.textContent = "Identifier non disponibile nel TTL";
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }

})();
</script>



{% endblock %}

{% endblock %}
